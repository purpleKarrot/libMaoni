
[c++]

[section Tutorial]
In Maoni everithing is optional.
The simplest application built on Maoni consist of zero lines of code.

[section Custom File Loader]
So we start by implementing a loader for meshes. To do so, declare a class and
inherit from `MeshLoader`. You will have to implement three virtual functions:

# `name()` shall return the name of your loader.
# `extension()` shall return the file extension (without the dot).
# `load()` shall read the mesh data from the file named `filename` and fill it
   into the [classref Model].

Lastly, create an instance of your loader. This may be either global, or static
inside your loader class. The result will be the same. Now your code would look
like this one:

  class PlyLoader: public ``[classref MeshLoader]``
  {
    const char* const name() const
    {
      return "Stanford PLY";
    }
  
    const char* const extension() const
    {
      return "ply";
    }
  
    void load(Model& model, const char* filename) const;
  
    static PlyLoader instance;
  };
  
  PlyLoader PlyLoader::instance;
  
  void PlyLoader::load(``[classref Model]``& model, const char* filename) const
  {
    ...
  }

It wouldn't be very DRY if you had to implement the same class skeleton for each
loader, so we provide the macro [macroref MESH_LOADER] as a shortcut. The following
code expands to the code above:

  MESH_LOADER(ply, Stanford PLY)
  {
    ...
  }

You can define as many loaders as you want. Just link them all together with libMaoni;
they will register themselves automatically.
[endsect]

[section Custom Render Algorithm]
Implementing rendering algorithms with libMaoni is very similar to implementing mesh
loaders. Again you just inherit your class from a provided parent, implement virtual
functions and create an instance. Again we provide a macro as a shortcut.

Inherit from [classref Algorithm] and implement the following functions:

# `name()` shall return the name of your renderer.
# `render()` contains your rendering code.
# `config()` is used to communicate your settings with libMaoni. This function is
  used to populate the user interface, serialize settings into XML and distribute
  them to other instances when rendering in parallel.

  example source

[macroref RENDER_ALGORITHM] helps you save some boilerplate: 

  example source  

[endsect]

[section Enumerations]

  some explanations
  
[endsect]

[section Custom Shader Programs]
To use shader programs, declare a class and inherit from [classref ShaderProgram]. In
the constructor, call [funcref ShaderProgram::attach] for each shader source string.

  struct MyProgram: ShaderProgram
  {
    MyProgram()
    {
      attach(GL_VERTEX_SHADER, vertex_source);
      attach(GL_FRAGMENT_SHADER, fragment_source);
    }
  };
  
As always, libMaoni provides a shortcut: [macroref SHADER_PROGRAM]. So you can simply
put:

  SHADER_PROGRAM(MyProgram,
    (VERTEX, vertex_source) (FRAGMENT, fragment_source),
  );

If you want to write the shader source code directly in your .cpp file, you may use the
macro [macroref SHADER_SOURCE]. This macro takes three parameters:

# the name of the shader. This is how the source string will be called.
# zero or more directives (without the `#`, each wrapped in braces). Used to specify
  the version, enable extensions and so on.
# the (unquoted) shader source code.

Example:

  SHADER_SOURCE(my_shader, (version 110) (extension all : disable),
    main()
    {
      ...
    }
  );

Will expand to:

  const char* const my_shader =
    "#version 110\n"
    "#extension all : disable\n"
    "main() { ... }";

To instanciate your shader program, use it as a member of your rendering algorithm.
Note that `ShaderProgram` and all derived classes convert implicitely to `GLuint`, so
you can pass a shader object directly to `glUseProgram`.
[endsect]
[endsect]
